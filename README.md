# Argo Guestbook

Final assignment in the CI/CD course at Lernia. Implementing GitOps with ArgoCD for a guestbook application.

## The Assignment

This assignment is a continuation of the final assignment of the Container Technology course at Lernia.

All files are based on the files from my previous assignment, which can be viewed at my GitLab account:

https://gitlab.com/SvartaStorken/guestbook-ubi10-yaml

The original assignment for the guestbook in the Container Technology course:
https://github.com/jonasbjork/ocp-guestbook/blob/main/README.md

## The Technical Part of the CI/CD Assignment
The following will be tested:

1. I should be able to view your guestbook at a URL provided in your submitted report. When I post an entry, it should be visible. I will then start my browser in incognito mode and open your URL again; my entry should be visible there as well.
2. I will change replicas from X (whatever you chose) to X+2 and verify that your guestbook scales up to this value. You will therefore need to add me as a collaborator on your GitHub repo. My GitHub profile can be found at: https://github.com/jonasbjork

## Infrastructure and Functionality

GitHub Actions will first deploy the secrets necessary to run the databases, followed by the ArgoCD deployment.

ArgoCD is configured to read all files in the `k8s` directory and deploy them to the cluster.

Once ArgoCD is deployed, it will deploy the guestbook as configured in its YAML files.

Any changes to the YAML files will trigger ArgoCD to redeploy.

The GitHub workflow also builds the Containerfiles and uploads them to the Quay.io registry to be downloaded by the OpenShift cluster. During the build, a SHA checksum is added to the image tag, and the image reference in the Kubernetes deployment file is updated, triggering an automatic ArgoCD deployment.

## Roadmap and Future Improvements

1. The `OPENSHIFT_TOKEN` variable lasts only 24 hours; a permanent login solution (e.g., Service Account) is needed to deploy secrets reliably.
2. The automatic build and detection is currently poorly tested. Changes to all Containerfiles need to be verified to ensure the GitHub Action automatically rebuilds them correctly.
3. HTTPS has not yet been implemented.
4. It would be beneficial to migrate the databases to use StatefulSets instead of standard Deployments.

## GitHub Secrets and Variables

To run the CI/CD pipeline successfully, the following secrets need to be configured in the repository settings under **Settings > Secrets and variables > Actions**.

| Secret Name | Description |
|-------------|-------------|
| `OPENSHIFT_SERVER` | The API URL for the OpenShift cluster. |
| `OPENSHIFT_TOKEN` | The authentication token for the OpenShift user (needs to be updated daily). |
| `ARGOCD_PASSWORD` | The `admin` password for the ArgoCD instance. |
| `DB_USER` | The username for the database application. |
| `DB_PASSWORD` | The password for the database application. |
| `DB_NAME` | The name of the database to be used. |
| `QUAY_USERNAME` | Username for the Quay.io container registry. |
| `QUAY_PASSWORD` | Password or Robot Token for Quay.io to allow pushing images. |
| `RH_USERNAME` | Red Hat account username (used to pull UBI base images). |
| `RH_PASSWORD` | Red Hat account password. |

## Templates

### argo-app-guestbook.yaml

This file is currently not used; I left it on GitHub for reference. It was generated by ArgoCD at the initial setup, and I used it to create the ArgoCD deployment command:

```bash
argocd app create mw-guestbook \
            --repo https://github.com/SvartaStorken/argo_guestbook.git \
            --path k8s \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace grupp2 \
            --project default \
            --sync-policy automated \
            --auto-prune \
            --self-heal \
            --upsert
```

### mw-secrets.yaml

This file is used as a template by the GitHub workflow, simply adding GitHub variables to the file and then deploying it to the cluster:

```yaml
- name: Inject secrets and apply
        env:
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
```
